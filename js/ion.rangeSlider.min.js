(function (n) { typeof define == "function" && define.amd ? define(["jquery"], function (t) { return n(t, document, window, navigator) }) : typeof exports == "object" ? n(require("jquery"), document, window, navigator) : n(jQuery, document, window, navigator) })(function (n, t, i, r, u) { "use strict"; var o = 0, f = function () { var i = r.userAgent, u = /msie\s\d+/i, t; return i.search(u) > 0 && (t = u.exec(i).toString(), t = t.split(" ")[1], t < 9) ? (n("html").addClass("lt-ie9"), !0) : !1 }(); Function.prototype.bind || (Function.prototype.bind = function (n) { var t = this, i = [].slice, r, u; if (typeof t != "function") throw new TypeError; return r = i.call(arguments, 1), u = function () { var e, o, f; return this instanceof u ? (e = function () { }, e.prototype = t.prototype, o = new e, f = t.apply(o, r.concat(i.call(arguments))), Object(f) === f) ? f : o : t.apply(n, r.concat(i.call(arguments))) }, u }); Array.prototype.indexOf || (Array.prototype.indexOf = function (n, t) { var r, f, u, i; if (this == null) throw new TypeError('"this" is null or not defined'); if ((f = Object(this), u = f.length >>> 0, u === 0) || (i = +t || 0, Math.abs(i) === Infinity && (i = 0), i >= u)) return -1; for (r = Math.max(i >= 0 ? i : u - Math.abs(i), 0); r < u;) { if (r in f && f[r] === n) return r; r++ } return -1 }); var s = '<span class="irs"><span class="irs-line" tabindex="0"><span class="irs-line-left"><\/span><span class="irs-line-mid"><\/span><span class="irs-line-right"><\/span><\/span><span class="irs-min">0<\/span><span class="irs-max">1<\/span><span class="irs-from">0<\/span><span class="irs-to">0<\/span><span class="irs-single">0<\/span><\/span><span class="irs-grid"><\/span><span class="irs-bar"><\/span>', h = '<span class="irs-bar-edge"><\/span><span class="irs-shadow shadow-single"><\/span><span class="irs-slider single"><\/span>', c = '<span class="irs-shadow shadow-from"><\/span><span class="irs-shadow shadow-to"><\/span><span class="irs-slider from"><\/span><span class="irs-slider to"><\/span>', l = '<span class="irs-disable-mask"><\/span>', e = function (r, f, e) { this.VERSION = "2.2.0"; this.input = r; this.plugin_count = e; this.current_plugin = 0; this.calc_count = 0; this.update_tm = 0; this.old_from = 0; this.old_to = 0; this.old_min_interval = null; this.raf_id = null; this.dragging = !1; this.force_redraw = !1; this.no_diapason = !1; this.has_tab_index = !0; this.is_key = !1; this.is_update = !1; this.is_start = !0; this.is_finish = !1; this.is_active = !1; this.is_resize = !1; this.is_click = !1; f = f || {}; this.$cache = { win: n(i), body: n(t.body), input: n(r), cont: null, rs: null, min: null, max: null, from: null, to: null, single: null, bar: null, line: null, s_single: null, s_from: null, s_to: null, shad_single: null, shad_from: null, shad_to: null, edge: null, grid: null, grid_labels: [] }; this.coords = { x_gap: 0, x_pointer: 0, w_rs: 0, w_rs_old: 0, w_handle: 0, p_gap: 0, p_gap_left: 0, p_gap_right: 0, p_step: 0, p_pointer: 0, p_handle: 0, p_single_fake: 0, p_single_real: 0, p_from_fake: 0, p_from_real: 0, p_to_fake: 0, p_to_real: 0, p_bar_x: 0, p_bar_w: 0, grid_gap: 0, big_num: 0, big: [], big_w: [], big_p: [], big_x: [] }; this.labels = { w_min: 0, w_max: 0, w_from: 0, w_to: 0, w_single: 0, p_min: 0, p_max: 0, p_from_fake: 0, p_from_left: 0, p_to_fake: 0, p_to_left: 0, p_single_fake: 0, p_single_left: 0 }; var o = this.$cache.input, s = o.prop("value"), c, h, l; c = { type: "single", min: 10, max: 100, from: null, to: null, step: 1, min_interval: 0, max_interval: 0, drag_interval: !1, values: [], p_values: [], from_fixed: !1, from_min: null, from_max: null, from_shadow: !1, to_fixed: !1, to_min: null, to_max: null, to_shadow: !1, prettify_enabled: !0, prettify_separator: " ", prettify: null, force_edges: !1, keyboard: !0, grid: !1, grid_margin: !0, grid_num: 4, grid_snap: !1, hide_min_max: !1, hide_from_to: !1, prefix: "", postfix: "", max_postfix: "", decorate_both: !0, values_separator: " â€” ", input_values_separator: ";", disable: !1, block: !1, extra_classes: "", scope: null, onStart: null, onChange: null, onFinish: null, onUpdate: null }; o[0].nodeName !== "INPUT" && console && console.warn && console.warn("Base element should be <input>!", o[0]); h = { type: o.data("type"), min: o.data("min"), max: o.data("max"), from: o.data("from"), to: o.data("to"), step: o.data("step"), min_interval: o.data("minInterval"), max_interval: o.data("maxInterval"), drag_interval: o.data("dragInterval"), values: o.data("values"), from_fixed: o.data("fromFixed"), from_min: o.data("fromMin"), from_max: o.data("fromMax"), from_shadow: o.data("fromShadow"), to_fixed: o.data("toFixed"), to_min: o.data("toMin"), to_max: o.data("toMax"), to_shadow: o.data("toShadow"), prettify_enabled: o.data("prettifyEnabled"), prettify_separator: o.data("prettifySeparator"), force_edges: o.data("forceEdges"), keyboard: o.data("keyboard"), grid: o.data("grid"), grid_margin: o.data("gridMargin"), grid_num: o.data("gridNum"), grid_snap: o.data("gridSnap"), hide_min_max: o.data("hideMinMax"), hide_from_to: o.data("hideFromTo"), prefix: o.data("prefix"), postfix: o.data("postfix"), max_postfix: o.data("maxPostfix"), decorate_both: o.data("decorateBoth"), values_separator: o.data("valuesSeparator"), input_values_separator: o.data("inputValuesSeparator"), disable: o.data("disable"), block: o.data("block"), extra_classes: o.data("extraClasses") }; h.values = h.values && h.values.split(","); for (l in h) h.hasOwnProperty(l) && (h[l] === u || h[l] === "") && delete h[l]; s !== u && s !== "" && (s = s.split(h.input_values_separator || f.input_values_separator || ";"), s[0] && s[0] == +s[0] && (s[0] = +s[0]), s[1] && s[1] == +s[1] && (s[1] = +s[1]), f && f.values && f.values.length ? (c.from = s[0] && f.values.indexOf(s[0]), c.to = s[1] && f.values.indexOf(s[1])) : (c.from = s[0] && +s[0], c.to = s[1] && +s[1])); n.extend(c, f); n.extend(c, h); this.options = c; this.update_check = {}; this.validate(); this.result = { input: this.$cache.input, slider: null, min: this.options.min, max: this.options.max, from: this.options.from, from_percent: 0, from_value: null, to: this.options.to, to_percent: 0, to_value: null }; this.init() }; e.prototype = { init: function (n) { this.no_diapason = !1; this.coords.p_step = this.convertToPercent(this.options.step, !0); this.target = "base"; this.toggleInput(); this.append(); this.setMinMax(); n ? (this.force_redraw = !0, this.calc(!0), this.callOnUpdate()) : (this.force_redraw = !0, this.calc(!0), this.callOnStart()); this.updateScene() }, append: function () { var n = '<span class="irs js-irs-' + this.plugin_count + " " + this.options.extra_classes + '"><\/span>'; this.$cache.input.before(n); this.$cache.input.prop("readonly", !0); this.$cache.cont = this.$cache.input.prev(); this.result.slider = this.$cache.cont; this.$cache.cont.html(s); this.$cache.rs = this.$cache.cont.find(".irs"); this.$cache.min = this.$cache.cont.find(".irs-min"); this.$cache.max = this.$cache.cont.find(".irs-max"); this.$cache.from = this.$cache.cont.find(".irs-from"); this.$cache.to = this.$cache.cont.find(".irs-to"); this.$cache.single = this.$cache.cont.find(".irs-single"); this.$cache.bar = this.$cache.cont.find(".irs-bar"); this.$cache.line = this.$cache.cont.find(".irs-line"); this.$cache.grid = this.$cache.cont.find(".irs-grid"); this.options.type === "single" ? (this.$cache.cont.append(h), this.$cache.edge = this.$cache.cont.find(".irs-bar-edge"), this.$cache.s_single = this.$cache.cont.find(".single"), this.$cache.from[0].style.visibility = "hidden", this.$cache.to[0].style.visibility = "hidden", this.$cache.shad_single = this.$cache.cont.find(".shadow-single")) : (this.$cache.cont.append(c), this.$cache.s_from = this.$cache.cont.find(".from"), this.$cache.s_to = this.$cache.cont.find(".to"), this.$cache.shad_from = this.$cache.cont.find(".shadow-from"), this.$cache.shad_to = this.$cache.cont.find(".shadow-to"), this.setTopHandler()); this.options.hide_from_to && (this.$cache.from[0].style.display = "none", this.$cache.to[0].style.display = "none", this.$cache.single[0].style.display = "none"); this.appendGrid(); this.options.disable ? (this.appendDisableMask(), this.$cache.input[0].disabled = !0) : (this.$cache.input[0].disabled = !1, this.removeDisableMask(), this.bindEvents()); this.options.disable || (this.options.block ? this.appendDisableMask() : this.removeDisableMask()); this.options.drag_interval && (this.$cache.bar[0].style.cursor = "ew-resize") }, setTopHandler: function () { var i = this.options.min, n = this.options.max, r = this.options.from, t = this.options.to; r > i && t === n ? this.$cache.s_from.addClass("type_last") : t < n && this.$cache.s_to.addClass("type_last") }, changeLevel: function (n) { switch (n) { case "single": this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake); this.$cache.s_single.addClass("state_hover"); break; case "from": this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake); this.$cache.s_from.addClass("state_hover"); this.$cache.s_from.addClass("type_last"); this.$cache.s_to.removeClass("type_last"); break; case "to": this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake); this.$cache.s_to.addClass("state_hover"); this.$cache.s_to.addClass("type_last"); this.$cache.s_from.removeClass("type_last"); break; case "both": this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake); this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer); this.$cache.s_to.removeClass("type_last"); this.$cache.s_from.removeClass("type_last") } }, appendDisableMask: function () { this.$cache.cont.append(l); this.$cache.cont.addClass("irs-disabled") }, removeDisableMask: function () { this.$cache.cont.remove(".irs-disable-mask"); this.$cache.cont.removeClass("irs-disabled") }, remove: function () { this.$cache.cont.remove(); this.$cache.cont = null; this.$cache.line.off("keydown.irs_" + this.plugin_count); this.$cache.body.off("touchmove.irs_" + this.plugin_count); this.$cache.body.off("mousemove.irs_" + this.plugin_count); this.$cache.win.off("touchend.irs_" + this.plugin_count); this.$cache.win.off("mouseup.irs_" + this.plugin_count); f && (this.$cache.body.off("mouseup.irs_" + this.plugin_count), this.$cache.body.off("mouseleave.irs_" + this.plugin_count)); this.$cache.grid_labels = []; this.coords.big = []; this.coords.big_w = []; this.coords.big_p = []; this.coords.big_x = []; cancelAnimationFrame(this.raf_id) }, bindEvents: function () { if (!this.no_diapason) { this.$cache.body.on("touchmove.irs_" + this.plugin_count, this.pointerMove.bind(this)); this.$cache.body.on("mousemove.irs_" + this.plugin_count, this.pointerMove.bind(this)); this.$cache.win.on("touchend.irs_" + this.plugin_count, this.pointerUp.bind(this)); this.$cache.win.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this)); this.$cache.line.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.line.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.line.on("focus.irs_" + this.plugin_count, this.pointerFocus.bind(this)); if (this.options.drag_interval && this.options.type === "double") { this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "both")); this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "both")) } else { this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")) } if (this.options.type === "single") { this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single")); this.$cache.s_single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single")); this.$cache.shad_single.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single")); this.$cache.s_single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single")); this.$cache.edge.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.shad_single.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")) } else { this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, null)); this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, null)); this.$cache.from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from")); this.$cache.s_from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from")); this.$cache.to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to")); this.$cache.s_to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to")); this.$cache.shad_from.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.shad_to.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from")); this.$cache.s_from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from")); this.$cache.to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to")); this.$cache.s_to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to")); this.$cache.shad_from.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")); this.$cache.shad_to.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click")) } if (this.options.keyboard) this.$cache.line.on("keydown.irs_" + this.plugin_count, this.key.bind(this, "keyboard")); if (f) { this.$cache.body.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this)); this.$cache.body.on("mouseleave.irs_" + this.plugin_count, this.pointerUp.bind(this)) } } }, pointerFocus: function () { if (!this.target) { var n, t; t = this.options.type === "single" ? this.$cache.single : this.$cache.from; n = t.offset().left; n += t.width() / 2 - 1; this.pointerClick("single", { preventDefault: function () { }, pageX: n }) } }, pointerMove: function (n) { if (this.dragging) { var t = n.pageX || n.originalEvent.touches && n.originalEvent.touches[0].pageX; this.coords.x_pointer = t - this.coords.x_gap; this.calc() } }, pointerUp: function (t) { if (this.current_plugin === this.plugin_count) { if (this.is_active) this.is_active = !1; else return; this.$cache.cont.find(".state_hover").removeClass("state_hover"); this.force_redraw = !0; f && n("*").prop("unselectable", !1); this.updateScene(); this.restoreOriginalMinInterval(); (n.contains(this.$cache.cont[0], t.target) || this.dragging) && this.callOnFinish(); this.dragging = !1 } }, pointerDown: function (t, i) { i.preventDefault(); var r = i.pageX || i.originalEvent.touches && i.originalEvent.touches[0].pageX; i.button !== 2 && (t === "both" && this.setTempMinInterval(), t || (t = this.target || "from"), this.current_plugin = this.plugin_count, this.target = t, this.is_active = !0, this.dragging = !0, this.coords.x_gap = this.$cache.rs.offset().left, this.coords.x_pointer = r - this.coords.x_gap, this.calcPointerPercent(), this.changeLevel(t), f && n("*").prop("unselectable", !0), this.$cache.line.trigger("focus"), this.updateScene()) }, pointerClick: function (n, t) { t.preventDefault(); var i = t.pageX || t.originalEvent.touches && t.originalEvent.touches[0].pageX; t.button !== 2 && (this.current_plugin = this.plugin_count, this.target = n, this.is_click = !0, this.coords.x_gap = this.$cache.rs.offset().left, this.coords.x_pointer = +(i - this.coords.x_gap).toFixed(), this.force_redraw = !0, this.calc(), this.$cache.line.trigger("focus")) }, key: function (n, t) { if (this.current_plugin === this.plugin_count && !t.altKey && !t.ctrlKey && !t.shiftKey && !t.metaKey) { switch (t.which) { case 83: case 65: case 40: case 37: t.preventDefault(); this.moveByKey(!1); break; case 87: case 68: case 38: case 39: t.preventDefault(); this.moveByKey(!0) }return !0 } }, moveByKey: function (n) { var i = this.coords.p_pointer, t = (this.options.max - this.options.min) / 100; t = this.options.step / t; n ? i += t : i -= t; this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * i); this.is_key = !0; this.calc() }, setMinMax: function () { if (this.options) { if (this.options.hide_min_max) { this.$cache.min[0].style.display = "none"; this.$cache.max[0].style.display = "none"; return } if (this.options.values.length) this.$cache.min.html(this.decorate(this.options.p_values[this.options.min])), this.$cache.max.html(this.decorate(this.options.p_values[this.options.max])); else { var n = this._prettify(this.options.min), t = this._prettify(this.options.max); this.result.min_pretty = n; this.result.max_pretty = t; this.$cache.min.html(this.decorate(n, this.options.min)); this.$cache.max.html(this.decorate(t, this.options.max)) } this.labels.w_min = this.$cache.min.outerWidth(!1); this.labels.w_max = this.$cache.max.outerWidth(!1) } }, setTempMinInterval: function () { var n = this.result.to - this.result.from; this.old_min_interval === null && (this.old_min_interval = this.options.min_interval); this.options.min_interval = n }, restoreOriginalMinInterval: function () { this.old_min_interval !== null && (this.options.min_interval = this.old_min_interval, this.old_min_interval = null) }, calc: function (n) { var t; if (this.options && (this.calc_count++, (this.calc_count === 10 || n) && (this.calc_count = 0, this.coords.w_rs = this.$cache.rs.outerWidth(!1), this.calcHandlePercent()), this.coords.w_rs)) { this.calcPointerPercent(); t = this.getHandleX(); this.target === "both" && (this.coords.p_gap = 0, t = this.getHandleX()); this.target === "click" && (this.coords.p_gap = this.coords.p_handle / 2, t = this.getHandleX(), this.target = this.options.drag_interval ? "both_one" : this.chooseHandle(t)); switch (this.target) { case "base": var f = (this.options.max - this.options.min) / 100, e = (this.result.from - this.options.min) / f, h = (this.result.to - this.options.min) / f; this.coords.p_single_real = this.toFixed(e); this.coords.p_from_real = this.toFixed(e); this.coords.p_to_real = this.toFixed(h); this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max); this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max); this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max); this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real); this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real); this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real); this.target = null; break; case "single": if (this.options.from_fixed) break; this.coords.p_single_real = this.convertToRealPercent(t); this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real); this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max); this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real); break; case "from": if (this.options.from_fixed) break; this.coords.p_from_real = this.convertToRealPercent(t); this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real); this.coords.p_from_real > this.coords.p_to_real && (this.coords.p_from_real = this.coords.p_to_real); this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max); this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from"); this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, "from"); this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real); break; case "to": if (this.options.to_fixed) break; this.coords.p_to_real = this.convertToRealPercent(t); this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real); this.coords.p_to_real < this.coords.p_from_real && (this.coords.p_to_real = this.coords.p_from_real); this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max); this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to"); this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, "to"); this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real); break; case "both": if (this.options.from_fixed || this.options.to_fixed) break; t = this.toFixed(t + this.coords.p_handle * .001); this.coords.p_from_real = this.convertToRealPercent(t) - this.coords.p_gap_left; this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real); this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max); this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from"); this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real); this.coords.p_to_real = this.convertToRealPercent(t) + this.coords.p_gap_right; this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real); this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max); this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to"); this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real); break; case "both_one": if (this.options.from_fixed || this.options.to_fixed) break; var o = this.convertToRealPercent(t), c = this.result.from_percent, l = this.result.to_percent, u = l - c, s = u / 2, i = o - s, r = o + s; i < 0 && (i = 0, r = i + u); r > 100 && (r = 100, i = r - u); this.coords.p_from_real = this.calcWithStep(i); this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max); this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real); this.coords.p_to_real = this.calcWithStep(r); this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max); this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real) }this.options.type === "single" ? (this.coords.p_bar_x = this.coords.p_handle / 2, this.coords.p_bar_w = this.coords.p_single_fake, this.result.from_percent = this.coords.p_single_real, this.result.from = this.convertToValue(this.coords.p_single_real), this.result.from_pretty = this._prettify(this.result.from), this.options.values.length && (this.result.from_value = this.options.values[this.result.from])) : (this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + this.coords.p_handle / 2), this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake), this.result.from_percent = this.coords.p_from_real, this.result.from = this.convertToValue(this.coords.p_from_real), this.result.from_pretty = this._prettify(this.result.from), this.result.to_percent = this.coords.p_to_real, this.result.to = this.convertToValue(this.coords.p_to_real), this.result.to_pretty = this._prettify(this.result.to), this.options.values.length && (this.result.from_value = this.options.values[this.result.from], this.result.to_value = this.options.values[this.result.to])); this.calcMinMax(); this.calcLabels() } }, calcPointerPercent: function () { if (!this.coords.w_rs) { this.coords.p_pointer = 0; return } this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer) ? this.coords.x_pointer = 0 : this.coords.x_pointer > this.coords.w_rs && (this.coords.x_pointer = this.coords.w_rs); this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100) }, convertToRealPercent: function (n) { var t = 100 - this.coords.p_handle; return n / t * 100 }, convertToFakePercent: function (n) { var t = 100 - this.coords.p_handle; return n / 100 * t }, getHandleX: function () { var t = 100 - this.coords.p_handle, n = this.toFixed(this.coords.p_pointer - this.coords.p_gap); return n < 0 ? n = 0 : n > t && (n = t), n }, calcHandlePercent: function () { this.coords.w_handle = this.options.type === "single" ? this.$cache.s_single.outerWidth(!1) : this.$cache.s_from.outerWidth(!1); this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100) }, chooseHandle: function (n) { if (this.options.type === "single") return "single"; var t = this.coords.p_from_real + (this.coords.p_to_real - this.coords.p_from_real) / 2; return n >= t ? this.options.to_fixed ? "from" : "to" : this.options.from_fixed ? "to" : "from" }, calcMinMax: function () { this.coords.w_rs && (this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100, this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100) }, calcLabels: function () { this.coords.w_rs && !this.options.hide_from_to && (this.options.type === "single" ? (this.labels.w_single = this.$cache.single.outerWidth(!1), this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100, this.labels.p_single_left = this.coords.p_single_fake + this.coords.p_handle / 2 - this.labels.p_single_fake / 2, this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake)) : (this.labels.w_from = this.$cache.from.outerWidth(!1), this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100, this.labels.p_from_left = this.coords.p_from_fake + this.coords.p_handle / 2 - this.labels.p_from_fake / 2, this.labels.p_from_left = this.toFixed(this.labels.p_from_left), this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake), this.labels.w_to = this.$cache.to.outerWidth(!1), this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100, this.labels.p_to_left = this.coords.p_to_fake + this.coords.p_handle / 2 - this.labels.p_to_fake / 2, this.labels.p_to_left = this.toFixed(this.labels.p_to_left), this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake), this.labels.w_single = this.$cache.single.outerWidth(!1), this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100, this.labels.p_single_left = (this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2 - this.labels.p_single_fake / 2, this.labels.p_single_left = this.toFixed(this.labels.p_single_left), this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake))) }, updateScene: function () { (this.raf_id && (cancelAnimationFrame(this.raf_id), this.raf_id = null), clearTimeout(this.update_tm), this.update_tm = null, this.options) && (this.drawHandles(), this.is_active ? this.raf_id = requestAnimationFrame(this.updateScene.bind(this)) : this.update_tm = setTimeout(this.updateScene.bind(this), 300)) }, drawHandles: function () { (this.coords.w_rs = this.$cache.rs.outerWidth(!1), this.coords.w_rs) && (this.coords.w_rs !== this.coords.w_rs_old && (this.target = "base", this.is_resize = !0), (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) && (this.setMinMax(), this.calc(!0), this.drawLabels(), this.options.grid && (this.calcGridMargin(), this.calcGridLabels()), this.force_redraw = !0, this.coords.w_rs_old = this.coords.w_rs, this.drawShadow()), this.coords.w_rs) && (this.dragging || this.force_redraw || this.is_key) && ((this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) && (this.drawLabels(), this.$cache.bar[0].style.left = this.coords.p_bar_x + "%", this.$cache.bar[0].style.width = this.coords.p_bar_w + "%", this.options.type === "single" ? (this.$cache.s_single[0].style.left = this.coords.p_single_fake + "%", this.$cache.single[0].style.left = this.labels.p_single_left + "%") : (this.$cache.s_from[0].style.left = this.coords.p_from_fake + "%", this.$cache.s_to[0].style.left = this.coords.p_to_fake + "%", (this.old_from !== this.result.from || this.force_redraw) && (this.$cache.from[0].style.left = this.labels.p_from_left + "%"), (this.old_to !== this.result.to || this.force_redraw) && (this.$cache.to[0].style.left = this.labels.p_to_left + "%"), this.$cache.single[0].style.left = this.labels.p_single_left + "%"), this.writeToInput(), this.old_from === this.result.from && this.old_to === this.result.to || this.is_start || (this.$cache.input.trigger("change"), this.$cache.input.trigger("input")), this.old_from = this.result.from, this.old_to = this.result.to, this.is_resize || this.is_update || this.is_start || this.is_finish || this.callOnChange(), (this.is_key || this.is_click) && (this.is_key = !1, this.is_click = !1, this.callOnFinish()), this.is_update = !1, this.is_resize = !1, this.is_finish = !1), this.is_start = !1, this.is_key = !1, this.is_click = !1, this.force_redraw = !1) }, drawLabels: function () { var e, t, n, r, u, i, f; if (this.options && (e = this.options.values.length, t = this.options.p_values, !this.options.hide_from_to)) if (this.options.type === "single") e ? (n = this.decorate(t[this.result.from]), this.$cache.single.html(n)) : (i = this._prettify(this.result.from), n = this.decorate(i, this.result.from), this.$cache.single.html(n)), this.calcLabels(), this.$cache.min[0].style.visibility = this.labels.p_single_left < this.labels.p_min + 1 ? "hidden" : "visible", this.$cache.max[0].style.visibility = this.labels.p_single_left + this.labels.p_single_fake > 99 - this.labels.p_max ? "hidden" : "visible"; else { e ? (this.options.decorate_both ? (n = this.decorate(t[this.result.from]), n += this.options.values_separator, n += this.decorate(t[this.result.to])) : n = this.decorate(t[this.result.from] + this.options.values_separator + t[this.result.to]), r = this.decorate(t[this.result.from]), u = this.decorate(t[this.result.to]), this.$cache.single.html(n), this.$cache.from.html(r), this.$cache.to.html(u)) : (i = this._prettify(this.result.from), f = this._prettify(this.result.to), this.options.decorate_both ? (n = this.decorate(i, this.result.from), n += this.options.values_separator, n += this.decorate(f, this.result.to)) : n = this.decorate(i + this.options.values_separator + f, this.result.to), r = this.decorate(i, this.result.from), u = this.decorate(f, this.result.to), this.$cache.single.html(n), this.$cache.from.html(r), this.$cache.to.html(u)); this.calcLabels(); var c = Math.min(this.labels.p_single_left, this.labels.p_from_left), h = this.labels.p_single_left + this.labels.p_single_fake, o = this.labels.p_to_left + this.labels.p_to_fake, s = Math.max(h, o); this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left ? (this.$cache.from[0].style.visibility = "hidden", this.$cache.to[0].style.visibility = "hidden", this.$cache.single[0].style.visibility = "visible", this.result.from === this.result.to ? (this.target === "from" ? this.$cache.from[0].style.visibility = "visible" : this.target === "to" ? this.$cache.to[0].style.visibility = "visible" : this.target || (this.$cache.from[0].style.visibility = "visible"), this.$cache.single[0].style.visibility = "hidden", s = o) : (this.$cache.from[0].style.visibility = "hidden", this.$cache.to[0].style.visibility = "hidden", this.$cache.single[0].style.visibility = "visible", s = Math.max(h, o))) : (this.$cache.from[0].style.visibility = "visible", this.$cache.to[0].style.visibility = "visible", this.$cache.single[0].style.visibility = "hidden"); this.$cache.min[0].style.visibility = c < this.labels.p_min + 1 ? "hidden" : "visible"; this.$cache.max[0].style.visibility = s > 99 - this.labels.p_max ? "hidden" : "visible" } }, drawShadow: function () { var n = this.options, i = this.$cache, e = typeof n.from_min == "number" && !isNaN(n.from_min), o = typeof n.from_max == "number" && !isNaN(n.from_max), s = typeof n.to_min == "number" && !isNaN(n.to_min), h = typeof n.to_max == "number" && !isNaN(n.to_max), t, r, u, f; n.type === "single" ? n.from_shadow && (e || o) ? (t = this.convertToPercent(e ? n.from_min : n.min), r = this.convertToPercent(o ? n.from_max : n.max) - t, t = this.toFixed(t - this.coords.p_handle / 100 * t), r = this.toFixed(r - this.coords.p_handle / 100 * r), t = t + this.coords.p_handle / 2, i.shad_single[0].style.display = "block", i.shad_single[0].style.left = t + "%", i.shad_single[0].style.width = r + "%") : i.shad_single[0].style.display = "none" : (n.from_shadow && (e || o) ? (t = this.convertToPercent(e ? n.from_min : n.min), r = this.convertToPercent(o ? n.from_max : n.max) - t, t = this.toFixed(t - this.coords.p_handle / 100 * t), r = this.toFixed(r - this.coords.p_handle / 100 * r), t = t + this.coords.p_handle / 2, i.shad_from[0].style.display = "block", i.shad_from[0].style.left = t + "%", i.shad_from[0].style.width = r + "%") : i.shad_from[0].style.display = "none", n.to_shadow && (s || h) ? (u = this.convertToPercent(s ? n.to_min : n.min), f = this.convertToPercent(h ? n.to_max : n.max) - u, u = this.toFixed(u - this.coords.p_handle / 100 * u), f = this.toFixed(f - this.coords.p_handle / 100 * f), u = u + this.coords.p_handle / 2, i.shad_to[0].style.display = "block", i.shad_to[0].style.left = u + "%", i.shad_to[0].style.width = f + "%") : i.shad_to[0].style.display = "none") }, writeToInput: function () { this.options.type === "single" ? (this.options.values.length ? this.$cache.input.prop("value", this.result.from_value) : this.$cache.input.prop("value", this.result.from), this.$cache.input.data("from", this.result.from)) : (this.options.values.length ? this.$cache.input.prop("value", this.result.from_value + this.options.input_values_separator + this.result.to_value) : this.$cache.input.prop("value", this.result.from + this.options.input_values_separator + this.result.to), this.$cache.input.data("from", this.result.from), this.$cache.input.data("to", this.result.to)) }, callOnStart: function () { if (this.writeToInput(), this.options.onStart && typeof this.options.onStart == "function") if (this.options.scope) this.options.onStart.call(this.options.scope, this.result); else this.options.onStart(this.result) }, callOnChange: function () { if (this.writeToInput(), this.options.onChange && typeof this.options.onChange == "function") if (this.options.scope) this.options.onChange.call(this.options.scope, this.result); else this.options.onChange(this.result) }, callOnFinish: function () { if (this.writeToInput(), this.options.onFinish && typeof this.options.onFinish == "function") if (this.options.scope) this.options.onFinish.call(this.options.scope, this.result); else this.options.onFinish(this.result) }, callOnUpdate: function () { if (this.writeToInput(), this.options.onUpdate && typeof this.options.onUpdate == "function") if (this.options.scope) this.options.onUpdate.call(this.options.scope, this.result); else this.options.onUpdate(this.result) }, toggleInput: function () { this.$cache.input.toggleClass("irs-hidden-input"); this.has_tab_index ? this.$cache.input.prop("tabindex", -1) : this.$cache.input.removeProp("tabindex"); this.has_tab_index = !this.has_tab_index }, convertToPercent: function (n, t) { var i = this.options.max - this.options.min, f = i / 100, r, u; return i ? (r = t ? n : n - this.options.min, u = r / f, this.toFixed(u)) : (this.no_diapason = !0, 0) }, convertToValue: function (n) { var i = this.options.min, h = this.options.max, c = i.toString().split(".")[1], l = h.toString().split(".")[1], u, f, e = 0, o = 0, t, s, r; return n === 0 ? this.options.min : n === 100 ? this.options.max : (c && (u = c.length, e = u), l && (f = l.length, e = f), u && f && (e = u >= f ? u : f), i < 0 && (o = Math.abs(i), i = +(i + o).toFixed(e), h = +(h + o).toFixed(e)), t = (h - i) / 100 * n + i, s = this.options.step.toString().split(".")[1], s ? t = +t.toFixed(s.length) : (t = t / this.options.step, t = t * this.options.step, t = +t.toFixed(0)), o && (t -= o), r = s ? +t.toFixed(s.length) : this.toFixed(t), r < this.options.min ? r = this.options.min : r > this.options.max && (r = this.options.max), r) }, calcWithStep: function (n) { var t = Math.round(n / this.coords.p_step) * this.coords.p_step; return t > 100 && (t = 100), n === 100 && (t = 100), this.toFixed(t) }, checkMinInterval: function (n, t, i) { var u = this.options, r, f; return u.min_interval ? (r = this.convertToValue(n), f = this.convertToValue(t), i === "from" ? f - r < u.min_interval && (r = f - u.min_interval) : r - f < u.min_interval && (r = f + u.min_interval), this.convertToPercent(r)) : n }, checkMaxInterval: function (n, t, i) { var u = this.options, r, f; return u.max_interval ? (r = this.convertToValue(n), f = this.convertToValue(t), i === "from" ? f - r > u.max_interval && (r = f - u.max_interval) : r - f > u.max_interval && (r = f + u.max_interval), this.convertToPercent(r)) : n }, checkDiapason: function (n, t, i) { var r = this.convertToValue(n), u = this.options; return typeof t != "number" && (t = u.min), typeof i != "number" && (i = u.max), r < t && (r = t), r > i && (r = i), this.convertToPercent(r) }, toFixed: function (n) { return n = n.toFixed(20), +n }, _prettify: function (n) { return this.options.prettify_enabled ? this.options.prettify && typeof this.options.prettify == "function" ? this.options.prettify(n) : this.prettify(n) : n }, prettify: function (n) { var t = n.toString(); return t.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + this.options.prettify_separator) }, checkEdges: function (n, t) { return this.options.force_edges ? (n < 0 ? n = 0 : n > 100 - t && (n = 100 - t), this.toFixed(n)) : this.toFixed(n) }, validate: function () { var n = this.options, t = this.result, u = n.values, f = u.length, i, r; if (typeof n.min == "string" && (n.min = +n.min), typeof n.max == "string" && (n.max = +n.max), typeof n.from == "string" && (n.from = +n.from), typeof n.to == "string" && (n.to = +n.to), typeof n.step == "string" && (n.step = +n.step), typeof n.from_min == "string" && (n.from_min = +n.from_min), typeof n.from_max == "string" && (n.from_max = +n.from_max), typeof n.to_min == "string" && (n.to_min = +n.to_min), typeof n.to_max == "string" && (n.to_max = +n.to_max), typeof n.grid_num == "string" && (n.grid_num = +n.grid_num), n.max < n.min && (n.max = n.min), f) for (n.p_values = [], n.min = 0, n.max = f - 1, n.step = 1, n.grid_num = n.max, n.grid_snap = !0, r = 0; r < f; r++)i = +u[r], isNaN(i) ? i = u[r] : (u[r] = i, i = this._prettify(i)), n.p_values.push(i); (typeof n.from != "number" || isNaN(n.from)) && (n.from = n.min); (typeof n.to != "number" || isNaN(n.to)) && (n.to = n.max); n.type === "single" ? (n.from < n.min && (n.from = n.min), n.from > n.max && (n.from = n.max)) : (n.from < n.min && (n.from = n.min), n.from > n.max && (n.from = n.max), n.to < n.min && (n.to = n.min), n.to > n.max && (n.to = n.max), this.update_check.from && (this.update_check.from !== n.from && n.from > n.to && (n.from = n.to), this.update_check.to !== n.to && n.to < n.from && (n.to = n.from)), n.from > n.to && (n.from = n.to), n.to < n.from && (n.to = n.from)); (typeof n.step != "number" || isNaN(n.step) || !n.step || n.step < 0) && (n.step = 1); typeof n.from_min == "number" && n.from < n.from_min && (n.from = n.from_min); typeof n.from_max == "number" && n.from > n.from_max && (n.from = n.from_max); typeof n.to_min == "number" && n.to < n.to_min && (n.to = n.to_min); typeof n.to_max == "number" && n.from > n.to_max && (n.to = n.to_max); t && (t.min !== n.min && (t.min = n.min), t.max !== n.max && (t.max = n.max), (t.from < t.min || t.from > t.max) && (t.from = n.from), (t.to < t.min || t.to > t.max) && (t.to = n.to)); (typeof n.min_interval != "number" || isNaN(n.min_interval) || !n.min_interval || n.min_interval < 0) && (n.min_interval = 0); (typeof n.max_interval != "number" || isNaN(n.max_interval) || !n.max_interval || n.max_interval < 0) && (n.max_interval = 0); n.min_interval && n.min_interval > n.max - n.min && (n.min_interval = n.max - n.min); n.max_interval && n.max_interval > n.max - n.min && (n.max_interval = n.max - n.min) }, decorate: function (n, t) { var r = "", i = this.options; return i.prefix && (r += i.prefix), r += n, i.max_postfix && (i.values.length && n === i.p_values[i.max] ? (r += i.max_postfix, i.postfix && (r += " ")) : t === i.max && (r += i.max_postfix, i.postfix && (r += " "))), i.postfix && (r += i.postfix), r }, updateFrom: function () { this.result.from = this.options.from; this.result.from_percent = this.convertToPercent(this.result.from); this.result.from_pretty = this._prettify(this.result.from); this.options.values && (this.result.from_value = this.options.values[this.result.from]) }, updateTo: function () { this.result.to = this.options.to; this.result.to_percent = this.convertToPercent(this.result.to); this.result.to_pretty = this._prettify(this.result.to); this.options.values && (this.result.to_value = this.options.values[this.result.to]) }, updateResult: function () { this.result.min = this.options.min; this.result.max = this.options.max; this.updateFrom(); this.updateTo() }, appendGrid: function () { if (this.options.grid) { var n = this.options, r, o, h = n.max - n.min, i = n.grid_num, u = 0, t = 0, f = 4, c, l, a = 0, e, s = ""; for (this.calcGridMargin(), n.grid_snap ? h > 50 ? (i = 50 / n.step, u = this.toFixed(n.step / .5)) : (i = h / n.step, u = this.toFixed(n.step / (h / 100))) : u = this.toFixed(100 / i), i > 4 && (f = 3), i > 7 && (f = 2), i > 14 && (f = 1), i > 28 && (f = 0), r = 0; r < i + 1; r++) { for (c = f, t = this.toFixed(u * r), t > 100 && (t = 100), this.coords.big[r] = t, l = (t - u * (r - 1)) / (c + 1), o = 1; o <= c; o++) { if (t === 0) break; a = this.toFixed(t - l * o); s += '<span class="irs-grid-pol small" style="left: ' + a + '%"><\/span>' } s += '<span class="irs-grid-pol" style="left: ' + t + '%"><\/span>'; e = this.convertToValue(t); e = n.values.length ? n.p_values[e] : this._prettify(e); s += '<span class="irs-grid-text js-grid-text-' + r + '" style="left: ' + t + '%">' + e + "<\/span>" } this.coords.big_num = Math.ceil(i + 1); this.$cache.cont.addClass("irs-with-grid"); this.$cache.grid.html(s); this.cacheGridLabels() } }, cacheGridLabels: function () { for (var t, i = this.coords.big_num, n = 0; n < i; n++)t = this.$cache.grid.find(".js-grid-text-" + n), this.$cache.grid_labels.push(t); this.calcGridLabels() }, calcGridLabels: function () { for (var u, i = [], r = [], t = this.coords.big_num, n = 0; n < t; n++)this.coords.big_w[n] = this.$cache.grid_labels[n].outerWidth(!1), this.coords.big_p[n] = this.toFixed(this.coords.big_w[n] / this.coords.w_rs * 100), this.coords.big_x[n] = this.toFixed(this.coords.big_p[n] / 2), i[n] = this.toFixed(this.coords.big[n] - this.coords.big_x[n]), r[n] = this.toFixed(i[n] + this.coords.big_p[n]); for (this.options.force_edges && (i[0] < -this.coords.grid_gap && (i[0] = -this.coords.grid_gap, r[0] = this.toFixed(i[0] + this.coords.big_p[0]), this.coords.big_x[0] = this.coords.grid_gap), r[t - 1] > 100 + this.coords.grid_gap && (r[t - 1] = 100 + this.coords.grid_gap, i[t - 1] = this.toFixed(r[t - 1] - this.coords.big_p[t - 1]), this.coords.big_x[t - 1] = this.toFixed(this.coords.big_p[t - 1] - this.coords.grid_gap))), this.calcGridCollision(2, i, r), this.calcGridCollision(4, i, r), n = 0; n < t; n++)u = this.$cache.grid_labels[n][0], this.coords.big_x[n] !== Number.POSITIVE_INFINITY && (u.style.marginLeft = -this.coords.big_x[n] + "%") }, calcGridCollision: function (n, t, i) { for (var u, f, e = this.coords.big_num, r = 0; r < e; r += n) { if (u = r + n / 2, u >= e) break; f = this.$cache.grid_labels[u][0]; f.style.visibility = i[r] <= t[u] ? "visible" : "hidden" } }, calcGridMargin: function () { this.options.grid_margin && (this.coords.w_rs = this.$cache.rs.outerWidth(!1), this.coords.w_rs) && (this.coords.w_handle = this.options.type === "single" ? this.$cache.s_single.outerWidth(!1) : this.$cache.s_from.outerWidth(!1), this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100), this.coords.grid_gap = this.toFixed(this.coords.p_handle / 2 - .1), this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + "%", this.$cache.grid[0].style.left = this.coords.grid_gap + "%") }, update: function (t) { this.input && (this.is_update = !0, this.options.from = this.result.from, this.options.to = this.result.to, this.update_check.from = this.result.from, this.update_check.to = this.result.to, this.options = n.extend(this.options, t), this.validate(), this.updateResult(t), this.toggleInput(), this.remove(), this.init(!0)) }, reset: function () { this.input && (this.updateResult(), this.update()) }, destroy: function () { this.input && (this.toggleInput(), this.$cache.input.prop("readonly", !1), n.data(this.input, "ionRangeSlider", null), this.remove(), this.input = null, this.options = null) } }; n.fn.ionRangeSlider = function (t) { return this.each(function () { n.data(this, "ionRangeSlider") || n.data(this, "ionRangeSlider", new e(this, t, o++)) }) }, function () { for (var r = 0, t = ["ms", "moz", "webkit", "o"], n = 0; n < t.length && !i.requestAnimationFrame; ++n)i.requestAnimationFrame = i[t[n] + "RequestAnimationFrame"], i.cancelAnimationFrame = i[t[n] + "CancelAnimationFrame"] || i[t[n] + "CancelRequestAnimationFrame"]; i.requestAnimationFrame || (i.requestAnimationFrame = function (n) { var t = (new Date).getTime(), u = Math.max(0, 16 - (t - r)), f = i.setTimeout(function () { n(t + u) }, u); return r = t + u, f }); i.cancelAnimationFrame || (i.cancelAnimationFrame = function (n) { clearTimeout(n) }) }() });